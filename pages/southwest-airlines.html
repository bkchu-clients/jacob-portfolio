<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="robots" content="noindex, nofollow" />
    <title>Password Protected Page</title>
    <style>
      @import url('https://fonts.googleapis.com/css?family=Roboto:400,400i,500,700|Space+Mono:400,700');
      *,
      *::before,
      *::after {
        box-sizing: border-box;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        font-family: 'Space Mono';
        font-size: 8px;
      }
      #dialogText {
        padding: 10px 30px;
        color: white;
        background-color: #ff5555;
        font-size: 2rem;
      }

      #dialogWrap {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: #eeeeee;
      }

      #dialogWrapCell {
        z-index: 9999;
        max-width: 90%;
      }

      #mainDialog {
        max-width: 400px;
        margin: 5px;
        border-radius: 4px;

        box-shadow: 4px 4px 8px 0 rgba(0, 0, 0, 0.2);
        margin-left: auto;
        margin-right: auto;
        background-color: #ffffff;
        overflow: hidden;
        text-align: left;
      }

      #passwordPrompt {
        font-size: 2rem;
      }

      #passArea {
        padding: 20px 30px;
        background-color: white;
      }
      #passArea > * {
        margin: 5px auto;
      }

      #pass {
        width: 100%;
        height: 40px;
        font-size: 2rem;
        border: solid 2px #3e3e3e;
        border-radius: 4px;
        padding: 1rem 1rem;
      }

      #messageWrapper {
        float: left;
        vertical-align: middle;
        line-height: 30px;
      }

      .notifyText {
        display: none;
      }

      #invalidPass {
        color: red;
      }

      #success {
        color: green;
      }

      #submitPass {
        font-family: 'Space Mono';
        font-size: 2rem;
        border-radius: 5px;
        background-color: #ff5555;
        color: white;
        padding: 1rem;
        border: 0;
        float: right;
      }
      #contentFrame {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }
    </style>
    <link rel="stylesheet" href="../css/normalize.css" />
    <link rel="stylesheet" href="../css/main.css" />
    <link rel="stylesheet" href="../css/header.css" />
  </head>
  <body>
    <iframe id="contentFrame" frameBorder="0" allowfullscreen></iframe>
    <div id="dialogWrap">
      <header class="main-header main-header--minimized grid">
        <div class="grid--inner">
          <a href="/" class="main-header__link link width-10">
            <img class="main-header__logo" src="../img/logo.svg" alt="logo" />
            <div>
              <h1 class="main-header__title">
                Jacob Kim
              </h1>
              <h2 class="main-header__subtitle">Digital <br class="mobile-only" />Product Designer</h2>
            </div>
          </a>
        </div>
      </header>
        <div id="dialogWrapCell">
            <div id="mainDialog">
                <div id="dialogText">This page is password protected.</div>
                <div id="passArea">
                    <p id="passwordPrompt">Password</p>
                    <input id="pass" type="password" name="pass">
                    <div>
                        <span id="messageWrapper">
                            <span id="invalidPass" class="notifyText">Sorry, please try again.</span>
                            <span id="success" class="notifyText">Success!</span>
                            &nbsp;
                        </span>
                        <button id="submitPass" type="button">Submit</button>
                        <div style="clear: both;"></div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <script>
      /*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
      var CryptoJS =
        CryptoJS ||
        (function(u, p) {
          var d = {},
            l = (d.lib = {}),
            s = function() {},
            t = (l.Base = {
              extend: function(a) {
                s.prototype = this;
                var c = new s();
                a && c.mixIn(a);
                c.hasOwnProperty('init') ||
                  (c.init = function() {
                    c.$super.init.apply(this, arguments);
                  });
                c.init.prototype = c;
                c.$super = this;
                return c;
              },
              create: function() {
                var a = this.extend();
                a.init.apply(a, arguments);
                return a;
              },
              init: function() {},
              mixIn: function(a) {
                for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
                a.hasOwnProperty('toString') && (this.toString = a.toString);
              },
              clone: function() {
                return this.init.prototype.extend(this);
              }
            }),
            r = (l.WordArray = t.extend({
              init: function(a, c) {
                a = this.words = a || [];
                this.sigBytes = c != p ? c : 4 * a.length;
              },
              toString: function(a) {
                return (a || v).stringify(this);
              },
              concat: function(a) {
                var c = this.words,
                  e = a.words,
                  j = this.sigBytes;
                a = a.sigBytes;
                this.clamp();
                if (j % 4)
                  for (var k = 0; k < a; k++)
                    c[(j + k) >>> 2] |=
                      ((e[k >>> 2] >>> (24 - 8 * (k % 4))) & 255) <<
                      (24 - 8 * ((j + k) % 4));
                else if (65535 < e.length)
                  for (k = 0; k < a; k += 4) c[(j + k) >>> 2] = e[k >>> 2];
                else c.push.apply(c, e);
                this.sigBytes += a;
                return this;
              },
              clamp: function() {
                var a = this.words,
                  c = this.sigBytes;
                a[c >>> 2] &= 4294967295 << (32 - 8 * (c % 4));
                a.length = u.ceil(c / 4);
              },
              clone: function() {
                var a = t.clone.call(this);
                a.words = this.words.slice(0);
                return a;
              },
              random: function(a) {
                for (var c = [], e = 0; e < a; e += 4)
                  c.push((4294967296 * u.random()) | 0);
                return new r.init(c, a);
              }
            })),
            w = (d.enc = {}),
            v = (w.Hex = {
              stringify: function(a) {
                var c = a.words;
                a = a.sigBytes;
                for (var e = [], j = 0; j < a; j++) {
                  var k = (c[j >>> 2] >>> (24 - 8 * (j % 4))) & 255;
                  e.push((k >>> 4).toString(16));
                  e.push((k & 15).toString(16));
                }
                return e.join('');
              },
              parse: function(a) {
                for (var c = a.length, e = [], j = 0; j < c; j += 2)
                  e[j >>> 3] |=
                    parseInt(a.substr(j, 2), 16) << (24 - 4 * (j % 8));
                return new r.init(e, c / 2);
              }
            }),
            b = (w.Latin1 = {
              stringify: function(a) {
                var c = a.words;
                a = a.sigBytes;
                for (var e = [], j = 0; j < a; j++)
                  e.push(
                    String.fromCharCode(
                      (c[j >>> 2] >>> (24 - 8 * (j % 4))) & 255
                    )
                  );
                return e.join('');
              },
              parse: function(a) {
                for (var c = a.length, e = [], j = 0; j < c; j++)
                  e[j >>> 2] |= (a.charCodeAt(j) & 255) << (24 - 8 * (j % 4));
                return new r.init(e, c);
              }
            }),
            x = (w.Utf8 = {
              stringify: function(a) {
                try {
                  return decodeURIComponent(escape(b.stringify(a)));
                } catch (c) {
                  throw Error('Malformed UTF-8 data');
                }
              },
              parse: function(a) {
                return b.parse(unescape(encodeURIComponent(a)));
              }
            }),
            q = (l.BufferedBlockAlgorithm = t.extend({
              reset: function() {
                this._data = new r.init();
                this._nDataBytes = 0;
              },
              _append: function(a) {
                'string' == typeof a && (a = x.parse(a));
                this._data.concat(a);
                this._nDataBytes += a.sigBytes;
              },
              _process: function(a) {
                var c = this._data,
                  e = c.words,
                  j = c.sigBytes,
                  k = this.blockSize,
                  b = j / (4 * k),
                  b = a ? u.ceil(b) : u.max((b | 0) - this._minBufferSize, 0);
                a = b * k;
                j = u.min(4 * a, j);
                if (a) {
                  for (var q = 0; q < a; q += k) this._doProcessBlock(e, q);
                  q = e.splice(0, a);
                  c.sigBytes -= j;
                }
                return new r.init(q, j);
              },
              clone: function() {
                var a = t.clone.call(this);
                a._data = this._data.clone();
                return a;
              },
              _minBufferSize: 0
            }));
          l.Hasher = q.extend({
            cfg: t.extend(),
            init: function(a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function() {
              q.reset.call(this);
              this._doReset();
            },
            update: function(a) {
              this._append(a);
              this._process();
              return this;
            },
            finalize: function(a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function(a) {
              return function(b, e) {
                return new a.init(e).finalize(b);
              };
            },
            _createHmacHelper: function(a) {
              return function(b, e) {
                return new n.HMAC.init(a, e).finalize(b);
              };
            }
          });
          var n = (d.algo = {});
          return d;
        })(Math);
      (function() {
        var u = CryptoJS,
          p = u.lib.WordArray;
        u.enc.Base64 = {
          stringify: function(d) {
            var l = d.words,
              p = d.sigBytes,
              t = this._map;
            d.clamp();
            d = [];
            for (var r = 0; r < p; r += 3)
              for (
                var w =
                    (((l[r >>> 2] >>> (24 - 8 * (r % 4))) & 255) << 16) |
                    (((l[(r + 1) >>> 2] >>> (24 - 8 * ((r + 1) % 4))) & 255) <<
                      8) |
                    ((l[(r + 2) >>> 2] >>> (24 - 8 * ((r + 2) % 4))) & 255),
                  v = 0;
                4 > v && r + 0.75 * v < p;
                v++
              )
                d.push(t.charAt((w >>> (6 * (3 - v))) & 63));
            if ((l = t.charAt(64))) for (; d.length % 4; ) d.push(l);
            return d.join('');
          },
          parse: function(d) {
            var l = d.length,
              s = this._map,
              t = s.charAt(64);
            t && ((t = d.indexOf(t)), -1 != t && (l = t));
            for (var t = [], r = 0, w = 0; w < l; w++)
              if (w % 4) {
                var v = s.indexOf(d.charAt(w - 1)) << (2 * (w % 4)),
                  b = s.indexOf(d.charAt(w)) >>> (6 - 2 * (w % 4));
                t[r >>> 2] |= (v | b) << (24 - 8 * (r % 4));
                r++;
              }
            return p.create(t, r);
          },
          _map:
            'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/='
        };
      })();
      (function(u) {
        function p(b, n, a, c, e, j, k) {
          b = b + ((n & a) | (~n & c)) + e + k;
          return ((b << j) | (b >>> (32 - j))) + n;
        }
        function d(b, n, a, c, e, j, k) {
          b = b + ((n & c) | (a & ~c)) + e + k;
          return ((b << j) | (b >>> (32 - j))) + n;
        }
        function l(b, n, a, c, e, j, k) {
          b = b + (n ^ a ^ c) + e + k;
          return ((b << j) | (b >>> (32 - j))) + n;
        }
        function s(b, n, a, c, e, j, k) {
          b = b + (a ^ (n | ~c)) + e + k;
          return ((b << j) | (b >>> (32 - j))) + n;
        }
        for (
          var t = CryptoJS,
            r = t.lib,
            w = r.WordArray,
            v = r.Hasher,
            r = t.algo,
            b = [],
            x = 0;
          64 > x;
          x++
        )
          b[x] = (4294967296 * u.abs(u.sin(x + 1))) | 0;
        r = r.MD5 = v.extend({
          _doReset: function() {
            this._hash = new w.init([
              1732584193,
              4023233417,
              2562383102,
              271733878
            ]);
          },
          _doProcessBlock: function(q, n) {
            for (var a = 0; 16 > a; a++) {
              var c = n + a,
                e = q[c];
              q[c] =
                (((e << 8) | (e >>> 24)) & 16711935) |
                (((e << 24) | (e >>> 8)) & 4278255360);
            }
            var a = this._hash.words,
              c = q[n + 0],
              e = q[n + 1],
              j = q[n + 2],
              k = q[n + 3],
              z = q[n + 4],
              r = q[n + 5],
              t = q[n + 6],
              w = q[n + 7],
              v = q[n + 8],
              A = q[n + 9],
              B = q[n + 10],
              C = q[n + 11],
              u = q[n + 12],
              D = q[n + 13],
              E = q[n + 14],
              x = q[n + 15],
              f = a[0],
              m = a[1],
              g = a[2],
              h = a[3],
              f = p(f, m, g, h, c, 7, b[0]),
              h = p(h, f, m, g, e, 12, b[1]),
              g = p(g, h, f, m, j, 17, b[2]),
              m = p(m, g, h, f, k, 22, b[3]),
              f = p(f, m, g, h, z, 7, b[4]),
              h = p(h, f, m, g, r, 12, b[5]),
              g = p(g, h, f, m, t, 17, b[6]),
              m = p(m, g, h, f, w, 22, b[7]),
              f = p(f, m, g, h, v, 7, b[8]),
              h = p(h, f, m, g, A, 12, b[9]),
              g = p(g, h, f, m, B, 17, b[10]),
              m = p(m, g, h, f, C, 22, b[11]),
              f = p(f, m, g, h, u, 7, b[12]),
              h = p(h, f, m, g, D, 12, b[13]),
              g = p(g, h, f, m, E, 17, b[14]),
              m = p(m, g, h, f, x, 22, b[15]),
              f = d(f, m, g, h, e, 5, b[16]),
              h = d(h, f, m, g, t, 9, b[17]),
              g = d(g, h, f, m, C, 14, b[18]),
              m = d(m, g, h, f, c, 20, b[19]),
              f = d(f, m, g, h, r, 5, b[20]),
              h = d(h, f, m, g, B, 9, b[21]),
              g = d(g, h, f, m, x, 14, b[22]),
              m = d(m, g, h, f, z, 20, b[23]),
              f = d(f, m, g, h, A, 5, b[24]),
              h = d(h, f, m, g, E, 9, b[25]),
              g = d(g, h, f, m, k, 14, b[26]),
              m = d(m, g, h, f, v, 20, b[27]),
              f = d(f, m, g, h, D, 5, b[28]),
              h = d(h, f, m, g, j, 9, b[29]),
              g = d(g, h, f, m, w, 14, b[30]),
              m = d(m, g, h, f, u, 20, b[31]),
              f = l(f, m, g, h, r, 4, b[32]),
              h = l(h, f, m, g, v, 11, b[33]),
              g = l(g, h, f, m, C, 16, b[34]),
              m = l(m, g, h, f, E, 23, b[35]),
              f = l(f, m, g, h, e, 4, b[36]),
              h = l(h, f, m, g, z, 11, b[37]),
              g = l(g, h, f, m, w, 16, b[38]),
              m = l(m, g, h, f, B, 23, b[39]),
              f = l(f, m, g, h, D, 4, b[40]),
              h = l(h, f, m, g, c, 11, b[41]),
              g = l(g, h, f, m, k, 16, b[42]),
              m = l(m, g, h, f, t, 23, b[43]),
              f = l(f, m, g, h, A, 4, b[44]),
              h = l(h, f, m, g, u, 11, b[45]),
              g = l(g, h, f, m, x, 16, b[46]),
              m = l(m, g, h, f, j, 23, b[47]),
              f = s(f, m, g, h, c, 6, b[48]),
              h = s(h, f, m, g, w, 10, b[49]),
              g = s(g, h, f, m, E, 15, b[50]),
              m = s(m, g, h, f, r, 21, b[51]),
              f = s(f, m, g, h, u, 6, b[52]),
              h = s(h, f, m, g, k, 10, b[53]),
              g = s(g, h, f, m, B, 15, b[54]),
              m = s(m, g, h, f, e, 21, b[55]),
              f = s(f, m, g, h, v, 6, b[56]),
              h = s(h, f, m, g, x, 10, b[57]),
              g = s(g, h, f, m, t, 15, b[58]),
              m = s(m, g, h, f, D, 21, b[59]),
              f = s(f, m, g, h, z, 6, b[60]),
              h = s(h, f, m, g, C, 10, b[61]),
              g = s(g, h, f, m, j, 15, b[62]),
              m = s(m, g, h, f, A, 21, b[63]);
            a[0] = (a[0] + f) | 0;
            a[1] = (a[1] + m) | 0;
            a[2] = (a[2] + g) | 0;
            a[3] = (a[3] + h) | 0;
          },
          _doFinalize: function() {
            var b = this._data,
              n = b.words,
              a = 8 * this._nDataBytes,
              c = 8 * b.sigBytes;
            n[c >>> 5] |= 128 << (24 - (c % 32));
            var e = u.floor(a / 4294967296);
            n[(((c + 64) >>> 9) << 4) + 15] =
              (((e << 8) | (e >>> 24)) & 16711935) |
              (((e << 24) | (e >>> 8)) & 4278255360);
            n[(((c + 64) >>> 9) << 4) + 14] =
              (((a << 8) | (a >>> 24)) & 16711935) |
              (((a << 24) | (a >>> 8)) & 4278255360);
            b.sigBytes = 4 * (n.length + 1);
            this._process();
            b = this._hash;
            n = b.words;
            for (a = 0; 4 > a; a++)
              (c = n[a]),
                (n[a] =
                  (((c << 8) | (c >>> 24)) & 16711935) |
                  (((c << 24) | (c >>> 8)) & 4278255360));
            return b;
          },
          clone: function() {
            var b = v.clone.call(this);
            b._hash = this._hash.clone();
            return b;
          }
        });
        t.MD5 = v._createHelper(r);
        t.HmacMD5 = v._createHmacHelper(r);
      })(Math);
      (function() {
        var u = CryptoJS,
          p = u.lib,
          d = p.Base,
          l = p.WordArray,
          p = u.algo,
          s = (p.EvpKDF = d.extend({
            cfg: d.extend({ keySize: 4, hasher: p.MD5, iterations: 1 }),
            init: function(d) {
              this.cfg = this.cfg.extend(d);
            },
            compute: function(d, r) {
              for (
                var p = this.cfg,
                  s = p.hasher.create(),
                  b = l.create(),
                  u = b.words,
                  q = p.keySize,
                  p = p.iterations;
                u.length < q;

              ) {
                n && s.update(n);
                var n = s.update(d).finalize(r);
                s.reset();
                for (var a = 1; a < p; a++) (n = s.finalize(n)), s.reset();
                b.concat(n);
              }
              b.sigBytes = 4 * q;
              return b;
            }
          }));
        u.EvpKDF = function(d, l, p) {
          return s.create(p).compute(d, l);
        };
      })();
      CryptoJS.lib.Cipher ||
        (function(u) {
          var p = CryptoJS,
            d = p.lib,
            l = d.Base,
            s = d.WordArray,
            t = d.BufferedBlockAlgorithm,
            r = p.enc.Base64,
            w = p.algo.EvpKDF,
            v = (d.Cipher = t.extend({
              cfg: l.extend(),
              createEncryptor: function(e, a) {
                return this.create(this._ENC_XFORM_MODE, e, a);
              },
              createDecryptor: function(e, a) {
                return this.create(this._DEC_XFORM_MODE, e, a);
              },
              init: function(e, a, b) {
                this.cfg = this.cfg.extend(b);
                this._xformMode = e;
                this._key = a;
                this.reset();
              },
              reset: function() {
                t.reset.call(this);
                this._doReset();
              },
              process: function(e) {
                this._append(e);
                return this._process();
              },
              finalize: function(e) {
                e && this._append(e);
                return this._doFinalize();
              },
              keySize: 4,
              ivSize: 4,
              _ENC_XFORM_MODE: 1,
              _DEC_XFORM_MODE: 2,
              _createHelper: function(e) {
                return {
                  encrypt: function(b, k, d) {
                    return ('string' == typeof k ? c : a).encrypt(e, b, k, d);
                  },
                  decrypt: function(b, k, d) {
                    return ('string' == typeof k ? c : a).decrypt(e, b, k, d);
                  }
                };
              }
            }));
          d.StreamCipher = v.extend({
            _doFinalize: function() {
              return this._process(!0);
            },
            blockSize: 1
          });
          var b = (p.mode = {}),
            x = function(e, a, b) {
              var c = this._iv;
              c ? (this._iv = u) : (c = this._prevBlock);
              for (var d = 0; d < b; d++) e[a + d] ^= c[d];
            },
            q = (d.BlockCipherMode = l.extend({
              createEncryptor: function(e, a) {
                return this.Encryptor.create(e, a);
              },
              createDecryptor: function(e, a) {
                return this.Decryptor.create(e, a);
              },
              init: function(e, a) {
                this._cipher = e;
                this._iv = a;
              }
            })).extend();
          q.Encryptor = q.extend({
            processBlock: function(e, a) {
              var b = this._cipher,
                c = b.blockSize;
              x.call(this, e, a, c);
              b.encryptBlock(e, a);
              this._prevBlock = e.slice(a, a + c);
            }
          });
          q.Decryptor = q.extend({
            processBlock: function(e, a) {
              var b = this._cipher,
                c = b.blockSize,
                d = e.slice(a, a + c);
              b.decryptBlock(e, a);
              x.call(this, e, a, c);
              this._prevBlock = d;
            }
          });
          b = b.CBC = q;
          q = (p.pad = {}).Pkcs7 = {
            pad: function(a, b) {
              for (
                var c = 4 * b,
                  c = c - (a.sigBytes % c),
                  d = (c << 24) | (c << 16) | (c << 8) | c,
                  l = [],
                  n = 0;
                n < c;
                n += 4
              )
                l.push(d);
              c = s.create(l, c);
              a.concat(c);
            },
            unpad: function(a) {
              a.sigBytes -= a.words[(a.sigBytes - 1) >>> 2] & 255;
            }
          };
          d.BlockCipher = v.extend({
            cfg: v.cfg.extend({ mode: b, padding: q }),
            reset: function() {
              v.reset.call(this);
              var a = this.cfg,
                b = a.iv,
                a = a.mode;
              if (this._xformMode == this._ENC_XFORM_MODE)
                var c = a.createEncryptor;
              else (c = a.createDecryptor), (this._minBufferSize = 1);
              this._mode = c.call(a, this, b && b.words);
            },
            _doProcessBlock: function(a, b) {
              this._mode.processBlock(a, b);
            },
            _doFinalize: function() {
              var a = this.cfg.padding;
              if (this._xformMode == this._ENC_XFORM_MODE) {
                a.pad(this._data, this.blockSize);
                var b = this._process(!0);
              } else (b = this._process(!0)), a.unpad(b);
              return b;
            },
            blockSize: 4
          });
          var n = (d.CipherParams = l.extend({
              init: function(a) {
                this.mixIn(a);
              },
              toString: function(a) {
                return (a || this.formatter).stringify(this);
              }
            })),
            b = ((p.format = {}).OpenSSL = {
              stringify: function(a) {
                var b = a.ciphertext;
                a = a.salt;
                return (a
                  ? s
                      .create([1398893684, 1701076831])
                      .concat(a)
                      .concat(b)
                  : b
                ).toString(r);
              },
              parse: function(a) {
                a = r.parse(a);
                var b = a.words;
                if (1398893684 == b[0] && 1701076831 == b[1]) {
                  var c = s.create(b.slice(2, 4));
                  b.splice(0, 4);
                  a.sigBytes -= 16;
                }
                return n.create({ ciphertext: a, salt: c });
              }
            }),
            a = (d.SerializableCipher = l.extend({
              cfg: l.extend({ format: b }),
              encrypt: function(a, b, c, d) {
                d = this.cfg.extend(d);
                var l = a.createEncryptor(c, d);
                b = l.finalize(b);
                l = l.cfg;
                return n.create({
                  ciphertext: b,
                  key: c,
                  iv: l.iv,
                  algorithm: a,
                  mode: l.mode,
                  padding: l.padding,
                  blockSize: a.blockSize,
                  formatter: d.format
                });
              },
              decrypt: function(a, b, c, d) {
                d = this.cfg.extend(d);
                b = this._parse(b, d.format);
                return a.createDecryptor(c, d).finalize(b.ciphertext);
              },
              _parse: function(a, b) {
                return 'string' == typeof a ? b.parse(a, this) : a;
              }
            })),
            p = ((p.kdf = {}).OpenSSL = {
              execute: function(a, b, c, d) {
                d || (d = s.random(8));
                a = w.create({ keySize: b + c }).compute(a, d);
                c = s.create(a.words.slice(b), 4 * c);
                a.sigBytes = 4 * b;
                return n.create({ key: a, iv: c, salt: d });
              }
            }),
            c = (d.PasswordBasedCipher = a.extend({
              cfg: a.cfg.extend({ kdf: p }),
              encrypt: function(b, c, d, l) {
                l = this.cfg.extend(l);
                d = l.kdf.execute(d, b.keySize, b.ivSize);
                l.iv = d.iv;
                b = a.encrypt.call(this, b, c, d.key, l);
                b.mixIn(d);
                return b;
              },
              decrypt: function(b, c, d, l) {
                l = this.cfg.extend(l);
                c = this._parse(c, l.format);
                d = l.kdf.execute(d, b.keySize, b.ivSize, c.salt);
                l.iv = d.iv;
                return a.decrypt.call(this, b, c, d.key, l);
              }
            }));
        })();
      (function() {
        for (
          var u = CryptoJS,
            p = u.lib.BlockCipher,
            d = u.algo,
            l = [],
            s = [],
            t = [],
            r = [],
            w = [],
            v = [],
            b = [],
            x = [],
            q = [],
            n = [],
            a = [],
            c = 0;
          256 > c;
          c++
        )
          a[c] = 128 > c ? c << 1 : (c << 1) ^ 283;
        for (var e = 0, j = 0, c = 0; 256 > c; c++) {
          var k = j ^ (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4),
            k = (k >>> 8) ^ (k & 255) ^ 99;
          l[e] = k;
          s[k] = e;
          var z = a[e],
            F = a[z],
            G = a[F],
            y = (257 * a[k]) ^ (16843008 * k);
          t[e] = (y << 24) | (y >>> 8);
          r[e] = (y << 16) | (y >>> 16);
          w[e] = (y << 8) | (y >>> 24);
          v[e] = y;
          y = (16843009 * G) ^ (65537 * F) ^ (257 * z) ^ (16843008 * e);
          b[k] = (y << 24) | (y >>> 8);
          x[k] = (y << 16) | (y >>> 16);
          q[k] = (y << 8) | (y >>> 24);
          n[k] = y;
          e ? ((e = z ^ a[a[a[G ^ z]]]), (j ^= a[a[j]])) : (e = j = 1);
        }
        var H = [0, 1, 2, 4, 8, 16, 32, 64, 128, 27, 54],
          d = (d.AES = p.extend({
            _doReset: function() {
              for (
                var a = this._key,
                  c = a.words,
                  d = a.sigBytes / 4,
                  a = 4 * ((this._nRounds = d + 6) + 1),
                  e = (this._keySchedule = []),
                  j = 0;
                j < a;
                j++
              )
                if (j < d) e[j] = c[j];
                else {
                  var k = e[j - 1];
                  j % d
                    ? 6 < d &&
                      4 == j % d &&
                      (k =
                        (l[k >>> 24] << 24) |
                        (l[(k >>> 16) & 255] << 16) |
                        (l[(k >>> 8) & 255] << 8) |
                        l[k & 255])
                    : ((k = (k << 8) | (k >>> 24)),
                      (k =
                        (l[k >>> 24] << 24) |
                        (l[(k >>> 16) & 255] << 16) |
                        (l[(k >>> 8) & 255] << 8) |
                        l[k & 255]),
                      (k ^= H[(j / d) | 0] << 24));
                  e[j] = e[j - d] ^ k;
                }
              c = this._invKeySchedule = [];
              for (d = 0; d < a; d++)
                (j = a - d),
                  (k = d % 4 ? e[j] : e[j - 4]),
                  (c[d] =
                    4 > d || 4 >= j
                      ? k
                      : b[l[k >>> 24]] ^
                        x[l[(k >>> 16) & 255]] ^
                        q[l[(k >>> 8) & 255]] ^
                        n[l[k & 255]]);
            },
            encryptBlock: function(a, b) {
              this._doCryptBlock(a, b, this._keySchedule, t, r, w, v, l);
            },
            decryptBlock: function(a, c) {
              var d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;
              this._doCryptBlock(a, c, this._invKeySchedule, b, x, q, n, s);
              d = a[c + 1];
              a[c + 1] = a[c + 3];
              a[c + 3] = d;
            },
            _doCryptBlock: function(a, b, c, d, e, j, l, f) {
              for (
                var m = this._nRounds,
                  g = a[b] ^ c[0],
                  h = a[b + 1] ^ c[1],
                  k = a[b + 2] ^ c[2],
                  n = a[b + 3] ^ c[3],
                  p = 4,
                  r = 1;
                r < m;
                r++
              )
                var q =
                    d[g >>> 24] ^
                    e[(h >>> 16) & 255] ^
                    j[(k >>> 8) & 255] ^
                    l[n & 255] ^
                    c[p++],
                  s =
                    d[h >>> 24] ^
                    e[(k >>> 16) & 255] ^
                    j[(n >>> 8) & 255] ^
                    l[g & 255] ^
                    c[p++],
                  t =
                    d[k >>> 24] ^
                    e[(n >>> 16) & 255] ^
                    j[(g >>> 8) & 255] ^
                    l[h & 255] ^
                    c[p++],
                  n =
                    d[n >>> 24] ^
                    e[(g >>> 16) & 255] ^
                    j[(h >>> 8) & 255] ^
                    l[k & 255] ^
                    c[p++],
                  g = q,
                  h = s,
                  k = t;
              q =
                ((f[g >>> 24] << 24) |
                  (f[(h >>> 16) & 255] << 16) |
                  (f[(k >>> 8) & 255] << 8) |
                  f[n & 255]) ^
                c[p++];
              s =
                ((f[h >>> 24] << 24) |
                  (f[(k >>> 16) & 255] << 16) |
                  (f[(n >>> 8) & 255] << 8) |
                  f[g & 255]) ^
                c[p++];
              t =
                ((f[k >>> 24] << 24) |
                  (f[(n >>> 16) & 255] << 16) |
                  (f[(g >>> 8) & 255] << 8) |
                  f[h & 255]) ^
                c[p++];
              n =
                ((f[n >>> 24] << 24) |
                  (f[(g >>> 16) & 255] << 16) |
                  (f[(h >>> 8) & 255] << 8) |
                  f[k & 255]) ^
                c[p++];
              a[b] = q;
              a[b + 1] = s;
              a[b + 2] = t;
              a[b + 3] = n;
            },
            keySize: 8
          }));
        u.AES = p._createHelper(d);
      })();
    </script>
    <script>
      /*
CryptoJS v3.1.2
code.google.com/p/crypto-js
(c) 2009-2013 by Jeff Mott. All rights reserved.
code.google.com/p/crypto-js/wiki/License
*/
      var CryptoJS =
        CryptoJS ||
        (function(g, j) {
          var e = {},
            d = (e.lib = {}),
            m = function() {},
            n = (d.Base = {
              extend: function(a) {
                m.prototype = this;
                var c = new m();
                a && c.mixIn(a);
                c.hasOwnProperty('init') ||
                  (c.init = function() {
                    c.$super.init.apply(this, arguments);
                  });
                c.init.prototype = c;
                c.$super = this;
                return c;
              },
              create: function() {
                var a = this.extend();
                a.init.apply(a, arguments);
                return a;
              },
              init: function() {},
              mixIn: function(a) {
                for (var c in a) a.hasOwnProperty(c) && (this[c] = a[c]);
                a.hasOwnProperty('toString') && (this.toString = a.toString);
              },
              clone: function() {
                return this.init.prototype.extend(this);
              }
            }),
            q = (d.WordArray = n.extend({
              init: function(a, c) {
                a = this.words = a || [];
                this.sigBytes = c != j ? c : 4 * a.length;
              },
              toString: function(a) {
                return (a || l).stringify(this);
              },
              concat: function(a) {
                var c = this.words,
                  p = a.words,
                  f = this.sigBytes;
                a = a.sigBytes;
                this.clamp();
                if (f % 4)
                  for (var b = 0; b < a; b++)
                    c[(f + b) >>> 2] |=
                      ((p[b >>> 2] >>> (24 - 8 * (b % 4))) & 255) <<
                      (24 - 8 * ((f + b) % 4));
                else if (65535 < p.length)
                  for (b = 0; b < a; b += 4) c[(f + b) >>> 2] = p[b >>> 2];
                else c.push.apply(c, p);
                this.sigBytes += a;
                return this;
              },
              clamp: function() {
                var a = this.words,
                  c = this.sigBytes;
                a[c >>> 2] &= 4294967295 << (32 - 8 * (c % 4));
                a.length = g.ceil(c / 4);
              },
              clone: function() {
                var a = n.clone.call(this);
                a.words = this.words.slice(0);
                return a;
              },
              random: function(a) {
                for (var c = [], b = 0; b < a; b += 4)
                  c.push((4294967296 * g.random()) | 0);
                return new q.init(c, a);
              }
            })),
            b = (e.enc = {}),
            l = (b.Hex = {
              stringify: function(a) {
                var c = a.words;
                a = a.sigBytes;
                for (var b = [], f = 0; f < a; f++) {
                  var d = (c[f >>> 2] >>> (24 - 8 * (f % 4))) & 255;
                  b.push((d >>> 4).toString(16));
                  b.push((d & 15).toString(16));
                }
                return b.join('');
              },
              parse: function(a) {
                for (var c = a.length, b = [], f = 0; f < c; f += 2)
                  b[f >>> 3] |=
                    parseInt(a.substr(f, 2), 16) << (24 - 4 * (f % 8));
                return new q.init(b, c / 2);
              }
            }),
            k = (b.Latin1 = {
              stringify: function(a) {
                var c = a.words;
                a = a.sigBytes;
                for (var b = [], f = 0; f < a; f++)
                  b.push(
                    String.fromCharCode(
                      (c[f >>> 2] >>> (24 - 8 * (f % 4))) & 255
                    )
                  );
                return b.join('');
              },
              parse: function(a) {
                for (var c = a.length, b = [], f = 0; f < c; f++)
                  b[f >>> 2] |= (a.charCodeAt(f) & 255) << (24 - 8 * (f % 4));
                return new q.init(b, c);
              }
            }),
            h = (b.Utf8 = {
              stringify: function(a) {
                try {
                  return decodeURIComponent(escape(k.stringify(a)));
                } catch (b) {
                  throw Error('Malformed UTF-8 data');
                }
              },
              parse: function(a) {
                return k.parse(unescape(encodeURIComponent(a)));
              }
            }),
            u = (d.BufferedBlockAlgorithm = n.extend({
              reset: function() {
                this._data = new q.init();
                this._nDataBytes = 0;
              },
              _append: function(a) {
                'string' == typeof a && (a = h.parse(a));
                this._data.concat(a);
                this._nDataBytes += a.sigBytes;
              },
              _process: function(a) {
                var b = this._data,
                  d = b.words,
                  f = b.sigBytes,
                  l = this.blockSize,
                  e = f / (4 * l),
                  e = a ? g.ceil(e) : g.max((e | 0) - this._minBufferSize, 0);
                a = e * l;
                f = g.min(4 * a, f);
                if (a) {
                  for (var h = 0; h < a; h += l) this._doProcessBlock(d, h);
                  h = d.splice(0, a);
                  b.sigBytes -= f;
                }
                return new q.init(h, f);
              },
              clone: function() {
                var a = n.clone.call(this);
                a._data = this._data.clone();
                return a;
              },
              _minBufferSize: 0
            }));
          d.Hasher = u.extend({
            cfg: n.extend(),
            init: function(a) {
              this.cfg = this.cfg.extend(a);
              this.reset();
            },
            reset: function() {
              u.reset.call(this);
              this._doReset();
            },
            update: function(a) {
              this._append(a);
              this._process();
              return this;
            },
            finalize: function(a) {
              a && this._append(a);
              return this._doFinalize();
            },
            blockSize: 16,
            _createHelper: function(a) {
              return function(b, d) {
                return new a.init(d).finalize(b);
              };
            },
            _createHmacHelper: function(a) {
              return function(b, d) {
                return new w.HMAC.init(a, d).finalize(b);
              };
            }
          });
          var w = (e.algo = {});
          return e;
        })(Math);
      (function() {
        var g = CryptoJS,
          j = g.lib,
          e = j.WordArray,
          d = j.Hasher,
          m = [],
          j = (g.algo.SHA1 = d.extend({
            _doReset: function() {
              this._hash = new e.init([
                1732584193,
                4023233417,
                2562383102,
                271733878,
                3285377520
              ]);
            },
            _doProcessBlock: function(d, e) {
              for (
                var b = this._hash.words,
                  l = b[0],
                  k = b[1],
                  h = b[2],
                  g = b[3],
                  j = b[4],
                  a = 0;
                80 > a;
                a++
              ) {
                if (16 > a) m[a] = d[e + a] | 0;
                else {
                  var c = m[a - 3] ^ m[a - 8] ^ m[a - 14] ^ m[a - 16];
                  m[a] = (c << 1) | (c >>> 31);
                }
                c = ((l << 5) | (l >>> 27)) + j + m[a];
                c =
                  20 > a
                    ? c + (((k & h) | (~k & g)) + 1518500249)
                    : 40 > a
                    ? c + ((k ^ h ^ g) + 1859775393)
                    : 60 > a
                    ? c + (((k & h) | (k & g) | (h & g)) - 1894007588)
                    : c + ((k ^ h ^ g) - 899497514);
                j = g;
                g = h;
                h = (k << 30) | (k >>> 2);
                k = l;
                l = c;
              }
              b[0] = (b[0] + l) | 0;
              b[1] = (b[1] + k) | 0;
              b[2] = (b[2] + h) | 0;
              b[3] = (b[3] + g) | 0;
              b[4] = (b[4] + j) | 0;
            },
            _doFinalize: function() {
              var d = this._data,
                e = d.words,
                b = 8 * this._nDataBytes,
                l = 8 * d.sigBytes;
              e[l >>> 5] |= 128 << (24 - (l % 32));
              e[(((l + 64) >>> 9) << 4) + 14] = Math.floor(b / 4294967296);
              e[(((l + 64) >>> 9) << 4) + 15] = b;
              d.sigBytes = 4 * e.length;
              this._process();
              return this._hash;
            },
            clone: function() {
              var e = d.clone.call(this);
              e._hash = this._hash.clone();
              return e;
            }
          }));
        g.SHA1 = d._createHelper(j);
        g.HmacSHA1 = d._createHmacHelper(j);
      })();
      (function() {
        var g = CryptoJS,
          j = g.enc.Utf8;
        g.algo.HMAC = g.lib.Base.extend({
          init: function(e, d) {
            e = this._hasher = new e.init();
            'string' == typeof d && (d = j.parse(d));
            var g = e.blockSize,
              n = 4 * g;
            d.sigBytes > n && (d = e.finalize(d));
            d.clamp();
            for (
              var q = (this._oKey = d.clone()),
                b = (this._iKey = d.clone()),
                l = q.words,
                k = b.words,
                h = 0;
              h < g;
              h++
            )
              (l[h] ^= 1549556828), (k[h] ^= 909522486);
            q.sigBytes = b.sigBytes = n;
            this.reset();
          },
          reset: function() {
            var e = this._hasher;
            e.reset();
            e.update(this._iKey);
          },
          update: function(e) {
            this._hasher.update(e);
            return this;
          },
          finalize: function(e) {
            var d = this._hasher;
            e = d.finalize(e);
            d.reset();
            return d.finalize(this._oKey.clone().concat(e));
          }
        });
      })();
      (function() {
        var g = CryptoJS,
          j = g.lib,
          e = j.Base,
          d = j.WordArray,
          j = g.algo,
          m = j.HMAC,
          n = (j.PBKDF2 = e.extend({
            cfg: e.extend({ keySize: 4, hasher: j.SHA1, iterations: 1 }),
            init: function(d) {
              this.cfg = this.cfg.extend(d);
            },
            compute: function(e, b) {
              for (
                var g = this.cfg,
                  k = m.create(g.hasher, e),
                  h = d.create(),
                  j = d.create([1]),
                  n = h.words,
                  a = j.words,
                  c = g.keySize,
                  g = g.iterations;
                n.length < c;

              ) {
                var p = k.update(b).finalize(j);
                k.reset();
                for (var f = p.words, v = f.length, s = p, t = 1; t < g; t++) {
                  s = k.finalize(s);
                  k.reset();
                  for (var x = s.words, r = 0; r < v; r++) f[r] ^= x[r];
                }
                h.concat(p);
                a[0]++;
              }
              h.sigBytes = 4 * c;
              return h;
            }
          }));
        g.PBKDF2 = function(d, b, e) {
          return n.create(e).compute(d, b);
        };
      })();
    </script>
    <script>
      /*! srcdoc-polyfill - v0.1.1 - 2013-03-01
       * http://github.com/jugglinmike/srcdoc-polyfill/
       * Copyright (c) 2013 Mike Pennisi; Licensed MIT */
      (function(window, document, undefined) {
        var idx, iframes;
        var _srcDoc = window.srcDoc;
        var isCompliant = !!('srcdoc' in document.createElement('iframe'));
        var implementations = {
          compliant: function(iframe, content) {
            if (content) {
              iframe.setAttribute('srcdoc', content);
            }
          },
          legacy: function(iframe, content) {
            var jsUrl;

            if (!iframe || !iframe.getAttribute) {
              return;
            }

            if (!content) {
              content = iframe.getAttribute('srcdoc');
            } else {
              iframe.setAttribute('srcdoc', content);
            }

            if (content) {
              // The value returned by a script-targeted URL will be used as
              // the iFrame's content. Create such a URL which returns the
              // iFrame element's `srcdoc` attribute.
              jsUrl = "javascript: window.frameElement.getAttribute('srcdoc');";

              iframe.setAttribute('src', jsUrl);

              // Explicitly set the iFrame's window.location for
              // compatability with IE9, which does not react to changes in
              // the `src` attribute when it is a `javascript:` URL, for
              // some reason
              if (iframe.contentWindow) {
                iframe.contentWindow.location = jsUrl;
              }
            }
          }
        };
        var srcDoc = (window.srcDoc = {
          // Assume the best
          set: implementations.compliant,
          noConflict: function() {
            window.srcDoc = _srcDoc;
            return srcDoc;
          }
        });

        // If the browser supports srcdoc, no shimming is necessary
        if (isCompliant) {
          return;
        }

        srcDoc.set = implementations.legacy;

        // Automatically shim any iframes already present in the document
        iframes = document.getElementsByTagName('iframe');
        idx = iframes.length;

        while (idx--) {
          srcDoc.set(iframes[idx]);
        }
      })(this, this.document);
    </script>
    <script>
      var pl = {
        salt: '7vg+AZf25/hWfs5eR/F1DLrma1aGdXb22xpRz4g2qao=',
        iv: 'E25CgARqfT4Q3TwPbIGk8A==',
        data:
          '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'
      };

      var submitPass = document.getElementById('submitPass');
      var passEl = document.getElementById('pass');
      var invalidPassEl = document.getElementById('invalidPass');
      var successEl = document.getElementById('success');
      var contentFrame = document.getElementById('contentFrame');

      if (pl === '') {
        submitPass.disabled = true;
        passEl.disabled = true;
        alert(
          "This page is meant to be used with the encryption tool. It doesn't work standalone."
        );
      }

      function doSubmit(evt) {
        try {
          var decrypted = decryptFile(
            CryptoJS.enc.Base64.parse(pl.data),
            passEl.value,
            CryptoJS.enc.Base64.parse(pl.salt),
            CryptoJS.enc.Base64.parse(pl.iv)
          );
          if (decrypted === '') throw 'No data returned';

          // Set default iframe link targets to _top so all links break out of the iframe
          decrypted = decrypted.replace(
            '<head>',
            '<head><base href="." target="_top">'
          );

          srcDoc.set(contentFrame, decrypted);

          successEl.style.display = 'inline';
          passEl.disabled = true;
          submitPass.disabled = true;
          setTimeout(function() {
            dialogWrap.style.display = 'none';
          }, 1000);
        } catch (e) {
          invalidPassEl.style.display = 'inline';
          passEl.value = '';
        }
      }

      submitPass.onclick = doSubmit;
      passEl.onkeypress = function(e) {
        if (!e) e = window.event;
        var keyCode = e.keyCode || e.which;
        invalidPassEl.style.display = 'none';
        if (keyCode == '13') {
          // Enter pressed
          doSubmit();
          return false;
        }
      };

      function decryptFile(contents, password, salt, iv) {
        var _cp = CryptoJS.lib.CipherParams.create({
          ciphertext: contents
        });
        var key = CryptoJS.PBKDF2(password, salt, {
          keySize: 256 / 32,
          iterations: 100
        });
        var decrypted = CryptoJS.AES.decrypt(_cp, key, { iv: iv });

        return decrypted.toString(CryptoJS.enc.Utf8);
      }
    </script>
  </body>
</html>
